var filesDownloadedQuantity;//已经至少被下载一次的文件数目
var filesDownloadList = [];
var serverController = [];
/*example:
var filesDownloadList=[
{“filename":"file1","DownloadUrl":"url1","serverNum":1,"DownloadedTimes":0,"originalMd5","0"},
{“filename":"file2","DownloadUrl":"url2","serverNum":1,"DownloadedTimes":1,"originalMd5","0"}
]serverNum是指该文件所在的服务器在serverController中的下标

	this.serverController = [
		//每个可服务器最多同时下载或下载两个文件
		{"serverName" : baidu ,  "availableDownloadUrls":2, "urlone" : 0, "urltwo" : 0},
		{"serverName" : sina ,   "availableDownloadUrls":2, "urlone" : 0, "urltwo" : 0},
		{"serverName" : jinshan ,"availableDownloadUrls":2, "urlone" : 0, "urltwo" : 0}
		];
*/
function downloadAccomplished(serverNum,fileToDownload ){//fileTodownload是正在下载的那个碎片编号
	if ( downloadServer == "sina" )
		return judgeSinaDownloadSuccess (fileToDownload);
	else if ( downloadServer == "jinshan" )
		return judgeJinShanDownloadSuccess (fileToDownload);
	//......
}
function downloadCallback(dataForm, serverNum ,fileToDownload){//fileTodownload:当前下载的文件碎片在filesdownloadList里的编号

	//在单个碎片的下载请求完成后调用的回调函数
	var downloadedMd5;
	var downloadSuccess = true;//记录是否下载成功

	if ( !downloadAccomplished() )//判断是否下载完成
		downloadSuccess = false;
	else
		serverController[serverNum].availableDownloadUrls ++;

	downloadedMd5 = getdownloadedMd5 (fileToDownload);//查询下载完成后的md5码
	if ( filesDownloadList[fileToDownload].originalMd5 !== downloadedMd5)//判断下载前后的md5码是否相同
		downloadSuccess = false;

	if( downloadSuccess ){// 下载完成且校验码相符，认为下载成功，下载次数+=0.5
		filesdownloadList[fileTodownload].downloadedTimes += 0.5;
		if( filesdownloadList[fileTodownload].downloadedTimes == 1)
			filesdownloadedQuantity ++;
	}
	else
		postDownloadHandlerByAJAX (dataForm,fileTodownload);//不成功则重新传一次
}

function downloadManager(dataForm){
	"strict mode"

	//初始化待下载文件列表
	var file;
	var minDownloadedTimes = 10000;
	var fileToDownload; //The next file to Download	
	var response;
	var i;
	var currentServerNum;//当前文件所在的服务器编号，因为结构体存取慢，所以用变量表示


	for ( i=0 ; i<filesDownloadList.length ;i++ )
		filesDownloadList[i].DownloadedTimes = 0;

	
	//每个可下载服务器最多同时下载两个文件
	for ( i=0 ; i<serverController.length ;i++ )
		serverController[i].availableDownloadUrls = 2;
	this.returnInformation = null;

	filesDownloadedQuantity = 0;

	//初始将所有碎片从0号开始依次都抛给服务器一遍（初始下载次数大家都是0，没必要一个个找下载次数最少的）
	i=0;currentServerNum= filesDownloadList[0].serverNum ;//currentServerNum即当前要下载的碎片所在服务器编号
	while( i<filesDownloadList.length ){
		if( serverController[currentServerNum].availableDownloadUrls !== 0 ){
			fileToDownload = i;
			filesDownloadList[fileToDownload].DownloadedTimes += 0.5;//文件列表规则为：已下载的加1，正在下载的加0.5
			//此处加0.5, 代表正在下载；postHandlerByAJAX监测文件传完后再加0.5，代表下载成功
			serverController[currentServerNum].availableDownloadUrls --;
			postDownloadHandlerByAJAX (dataForm,fileToDownload);//调用包装好的post put请求
			i++;currentServerNum = filesDownloadList[i].serverNum ;
		}
		else{
			setTimeout({}, 50);
		}
	}
	while( filesDownloadedQuantity <= filesDownloadList.length ){/*并非所有文件都下载过一次*/
		if( availableServerQuantity !== 0 ){
			//先从filesDownloadList列表中获取需要下载的一个文件（要求，下载次数最少）
			minDownloadedTimes = 10000；
			for( i=0 ; i<filesDownloadList.length ; i++ )
				if( filesDownloadList[i].DownloadedTimes < minDownloadedTimes ){
					fileToDownload = i ;
					minDownloadedTimes = filesDownloadList[i].DownloadedTimes ;
				}
			//以下这段同前一个while循环里语句的意义						
			filesDownloadList[fileToDownload].DownloadedTimes += 0.5;
			postDownloadHandlerByAJAX_Download (dataForm,fileToDownload,targetDownloadTimes);
		}
		else{
			setTimeout({}, 50);
			//sleep一段时间再查询
		}
	}
//下载没必要两次吧?我把询问是否下载两次的代码删了
 	//下载结束，返回保存信息
	this.returnInformation = []
};