# 基本框架
(把类似类的东西直接称为类)
## user.js
所有用户操作,与用户信息.可能需要拓展,所以打包成类.
## ownServer.js
和自己的服务器通讯的所有方法打包
## main.js
主程序
## fileSystem.js (TODO)
所有文件系统的操作打包.包括碎片上传控制.for循环构建碎片实例并且上传,回调函数中cnt为n时触发上传完成过程.
## frag.js (TODO)
所有碎片的信息与操作打包成类.每个碎片是一个实例.其中包括碎片上传下载方法.
## 每一个网盘一个类.封装好接口仅仅和frag.js通信

# tips from bey
/*
*看函数之前请先把所有函数都折叠起来
*所有之前在server communication里面的函数都放在了ownServer里面了，
*函数名字没变，调用时在最前面加上"ownServer."就好
*initial包括了一些常量的设置，可以在这里改，为了方便修改而放在文件最开头的
*tool里面的函数是一个快盘的签名，两个算hash值的，两个转换list的函数，名字被我缩短了一下
*其余的函数的作用在把代码块折叠起来，最后的那个"}"后面的注释里，
*或者直接点那几个xxxxxxxxHandler函数..进去的接口都在那些地方
*现在的目标：
*(0)重新设计函数的封装..现在已经改了一点，好一点了（至少那些常量在initial里面改就行）（然而下载那一坨还是糟的要死）
*(1)上传容错处理，什么404什么405什么500错误，是不是出错到一定次数就把那个网盘停用掉..那个算错误率的权应该怎么定，
还有服务器有每分钟的请求次数的限制，要考虑到这点（连续错误时的反复请求频率太高了）
*(2)增加几个网盘
*(3)增加进度条和速度监控，已知大多jQuery上传控件都有速度显示模块，可以去参考那些是怎么写的
*(4)上传一次半or两次or三次or某一个（概率论确定的冗余方案的次数?），的上传策略
*(5)下载策略还可以优化..比如说万一有速度了..是不是先下只有一个服务器有的，然后下剩下最快的..
*(6)发现这个文件没改好..那个叫getFragList的函数没写，downloadhandler的函数也没写好..
我考虑的是，现在这样的数据结构才导致download会比upload复杂那么多，多用那么多函数的..
所以我在想能不能设计一个更好索引到长度又能索引到内容的数据结构来解决这个问题
比方说，现在的问题是a={ index:1,
						server:{
								{name:xx,addr:xx}
								}
						}
并且a还是数组中的一个元素
现在既需要index，也需要server，就不能单独扣server里面的内容出来，（因为都要传进一个函数里来保证回调函数能够知道当前完成的碎片的index）
然后每次查长度就要查server的列表的长度（看是不是只有一个服务器有这个文件的碎片）
每次查某个服务器是否在server里面就要遍历server列表（因为发送一个download请求是要根据不同的name来调用不同的函数的）
*/